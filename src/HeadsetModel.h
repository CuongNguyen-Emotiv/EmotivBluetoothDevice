#ifndef EMOTIVDEVICEMODEL_H
#define EMOTIVDEVICEMODEL_H

#include <QBluetoothAddress>
#include <QBluetoothDeviceInfo>
#include <QAbstractListModel>

struct HeadsetItem
{
    QBluetoothDeviceInfo mBluetoothDeviceInfo;
    QString address() const {
#ifdef Q_OS_DARWIN
        // On OS X and iOS we do not have addresses,
        // only unique UUIDs generated by Core Bluetooth.
        return mBluetoothDeviceInfo.deviceUuid().toString();
#else
        return device.address().toString();
#endif
    }

    bool operator==(const HeadsetItem &other) const {
        return address() == other.address();
    }
};

class HeadsetModel : public QAbstractListModel
{
    Q_OBJECT
public:
    enum class EmotiveDeviceRole {
        NAME_ROLE = Qt::UserRole + 1,
        BLUETOOTH_DEVICE_INFO_ROLE,
        ADDRESS_ROLE,
        RSSI_ROLE,
    };
    explicit HeadsetModel(QObject *parent = nullptr);

    // QAbstractItemModel interface
    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role) const override;
    QHash<int, QByteArray> roleNames() const override;

    void addHeadset(const HeadsetItem &device);
    void removeHeadset(const HeadsetItem &device);
    void clear();

private:
    QList<HeadsetItem> mHeadsetItems;
};

#endif // EMOTIVDEVICEMODEL_H
